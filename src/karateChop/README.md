# Karate Chop

バイナリ・チョップ（より平凡なバイナリサーチと呼ばれることもある）は、値のソートされた配列の中で値の位置を見つけるものである。最初のパスで、必要な値が値のリストの上半分か下半分にあるかどうかを判断します。最初のパスでは、必要な値がリストの上半分にあるか下半分にあるかを判断し、2 回目のパスでは、この半分だけを考慮し、再び 2 つに分割する。探している値が見つかるか、検索する配列がなくなると停止する。バイナリサーチは、CS の講師がよく使う手法だ。

この型は簡単です。バイナリサーチのルーチンを（以下の仕様で）好きな言語と手法で実装しなさい。明日、全く別の手法でもう一度実装してください。翌日も同様にして、5 つの全くユニークなバイナリサーチの実装を完成させなさい（例えば、1 つは伝統的な反復法、1 つは再帰的、1 つは配列スライスを渡す関数型、などなど）。

## ゴール

このカタは 3 つのゴールに分かれています。

1. 各アルゴリズムをコーディングする際に、どのようなエラーが発生したかを記録しておくこと。バイナリサーチは、"off by one "やフェンスポストエラーの温床になります。つまり、ある手法での経験から、別の手法でコーディングするときに学ぶことができるかどうかということです。

2. あなたが選んださまざまなテクニックの相対的なメリットについて、何が言えるでしょうか？プロダクションコードにする可能性が最も高いのはどれですか？書いていて一番楽しかったのはどれですか？動作させるのが最も難しいのはどれか？そして、これらすべての質問について、「なぜか」と自問してください。

3. バイナリーチョップに対して 5 つのユニークなアプローチを考え出すのは、かなり難しいことです。4 と 5 のアプローチはどのようにして思いついたのですか？また、そのような「常識はずれの」ニューロンを起動させるために、どのようなテクニックを使いましたか？

## 仕様

整数の検索ターゲットと整数のソートされた配列を受け取るバイナリ・チョップ・メソッドを書いて下さい。このメソッドは、配列内の検索対象のインデックスを返すか、配列内に検索対象がない場合は -1 を返さなければなりません。シグネチャは論理的に次のようになります。

```
chop(int, array_of_int)  -> int
```

配列の要素は 10 万個以下と仮定してよい。この Kata の目的では、時間とメモリのパフォーマンスは問題ではありません（飽きる前にチョップが終了し、実行するのに十分な RAM があると仮定しています）。

## テストデータ

以下は、私のメソッドを開発する際に使用した Test::Unit のコードです。自由に追加してください。テストは配列のインデックスが 0 から始まると仮定しています。おそらく、あなたが選んだ言語でこれをコンパイルするためには、グローバルな検索と置換をいくつか行う必要があるでしょう（あなたの賢明な選択がたまたま Ruby でない限り）。

```
def test_chop
  assert_equal(-1, chop(3, []))
  assert_equal(-1, chop(3, [1]))
  assert_equal(0,  chop(1, [1]))
  #
  assert_equal(0,  chop(1, [1, 3, 5]))
  assert_equal(1,  chop(3, [1, 3, 5]))
  assert_equal(2,  chop(5, [1, 3, 5]))
  assert_equal(-1, chop(0, [1, 3, 5]))
  assert_equal(-1, chop(2, [1, 3, 5]))
  assert_equal(-1, chop(4, [1, 3, 5]))
  assert_equal(-1, chop(6, [1, 3, 5]))
  #
  assert_equal(0,  chop(1, [1, 3, 5, 7]))
  assert_equal(1,  chop(3, [1, 3, 5, 7]))
  assert_equal(2,  chop(5, [1, 3, 5, 7]))
  assert_equal(3,  chop(7, [1, 3, 5, 7]))
  assert_equal(-1, chop(0, [1, 3, 5, 7]))
  assert_equal(-1, chop(2, [1, 3, 5, 7]))
  assert_equal(-1, chop(4, [1, 3, 5, 7]))
  assert_equal(-1, chop(6, [1, 3, 5, 7]))
  assert_equal(-1, chop(8, [1, 3, 5, 7]))
end
```
